<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<title>src/honeycomb</title>
<link rel="stylesheet" type="text/css" href="nimdoc.out.css">

<script type="text/javascript" src="dochack.js"></script>

<script type="text/javascript">
function main() {
  var pragmaDots = document.getElementsByClassName("pragmadots");
  for (var i = 0; i < pragmaDots.length; i++) {
    pragmaDots[i].onclick = function(event) {
      // Hide tease
      event.target.parentNode.style.display = "none";
      // Show actual
      event.target.parentNode.nextElementSibling.style.display = "inline";
    }
  }

  function switchTheme(e) {
      if (e.target.checked) {
          document.documentElement.setAttribute('data-theme', 'dark');
          localStorage.setItem('theme', 'dark');
      } else {
          document.documentElement.setAttribute('data-theme', 'light');
          localStorage.setItem('theme', 'light');
      }
  }

  const toggleSwitch = document.querySelector('.theme-switch input[type="checkbox"]');
  if (toggleSwitch !== null) {
    toggleSwitch.addEventListener('change', switchTheme, false);
  }

  var currentTheme = localStorage.getItem('theme');
  if (!currentTheme && window.matchMedia('(prefers-color-scheme: dark)').matches) {
    currentTheme = 'dark';
  }
  if (currentTheme) {
    document.documentElement.setAttribute('data-theme', currentTheme);

    if (currentTheme === 'dark' && toggleSwitch !== null) {
      toggleSwitch.checked = true;
    }
  }
}

window.addEventListener('DOMContentLoaded', main);
</script>

</head>
<body>
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">src/honeycomb</h1>
    <div class="row">
  <div class="three columns">
  <div class="theme-switch-wrapper">
    <label class="theme-switch" for="checkbox">
      <input type="checkbox" id="checkbox" />
      <div class="slider round"></div>
    </label>
    &nbsp;&nbsp;&nbsp; <em>Dark Mode</em>
  </div>
  <div id="global-links">
    <ul class="simple">
    <li>
      <a href="theindex.html">Index</a>
    </li>
    </ul>
  </div>
  <div id="searchInputDiv">
    Search: <input type="text" id="searchInput"
      onkeyup="search()" />
  </div>
  <div>
    Group by:
    <select onchange="groupBy(this.value)">
      <option value="section">Section</option>
      <option value="type">Type</option>
    </select>
  </div>
  <ul class="simple simple-toc" id="toc-list">
<li>
  <a class="reference reference-toplevel" href="#7" id="57">Types</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#Parser"
    title="Parser[T] = proc (input: string): ParseResult[T]">Parser</a></li>
  <li><a class="reference" href="#ParseResult"
    title="ParseResult[T] = object
  case kind*: ParseResultKind
  of success:
    value*: T                ## The value of the successful parse.
  of failure:
    error*: string           ## The error message of the failed parse.
  tail*: string              ## The remaining unparsed input, or all input when failed.
  fromInput*: string         ## The input from which this result was generated.">ParseResult</a></li>
  <li><a class="reference" href="#ParseResultKind"
    title="ParseResultKind = enum
  success, failure">ParseResultKind</a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#9" id="59">Lets</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#alphanumeric"
    title="alphanumeric = letter | digit">alphanumeric</a></li>
  <li><a class="reference" href="#anyChar"
    title="anyChar = anyCharImpl">anyChar</a></li>
  <li><a class="reference" href="#digit"
    title="digit = c(&quot;0123456789&quot;)">digit</a></li>
  <li><a class="reference" href="#eof"
    title="eof = eofImpl">eof</a></li>
  <li><a class="reference" href="#letter"
    title="letter = c(&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;)">letter</a></li>
  <li><a class="reference" href="#whitespace"
    title="whitespace = regex(r&quot;\s+&quot;)">whitespace</a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#12" id="62">Procs</a>
  <ul class="simple simple-toc-section">
      <ul class="simple nested-toc-section">&
      <li><a class="reference" href="#%26%2CParser%5BT%5D%2CParser%5BT%5D"
    title="`&amp;`[T](a, b: Parser[T]): Parser[seq[T]]">`&amp;`[T](a, b: Parser[T]): Parser[seq[T]]</a></li>
  <li><a class="reference" href="#%26%2CParser%5Bseq%5BT%5D%5D%2CParser%5BT%5D"
    title="`&amp;`[T](a: Parser[seq[T]]; b: Parser[T]): Parser[seq[T]]">`&amp;`[T](a: Parser[seq[T]]; b: Parser[T]): Parser[seq[T]]</a></li>
  <li><a class="reference" href="#%26%2CParser%5BT%5D%2CParser%5Bseq%5BT%5D%5D"
    title="`&amp;`[T](a: Parser[T]; b: Parser[seq[T]]): Parser[seq[T]]">`&amp;`[T](a: Parser[T]; b: Parser[seq[T]]): Parser[seq[T]]</a></li>

  </ul>
  <ul class="simple nested-toc-section">*
      <li><a class="reference" href="#%2A%2CParser%5BT%5D%2CHSlice%5Bint%2Cint%5D"
    title="`*`[T](a: Parser[T]; n: HSlice[int, int]): Parser[seq[T]]">`*`[T](a: Parser[T]; n: HSlice[int, int]): Parser[seq[T]]</a></li>
  <li><a class="reference" href="#%2A%2CParser%5BT%5D%2Cint"
    title="`*`[T](a: Parser[T]; n: int): Parser[seq[T]]">`*`[T](a: Parser[T]; n: int): Parser[seq[T]]</a></li>

  </ul>
  <ul class="simple nested-toc-section"><<
      <li><a class="reference" href="#%3C%3C%2CParser%5BT%5D%2CParser"
    title="`&lt;&lt;`[T](a: Parser[T]; b: Parser): Parser[T]">`&lt;&lt;`[T](a: Parser[T]; b: Parser): Parser[T]</a></li>

  </ul>
  <ul class="simple nested-toc-section">>>
      <li><a class="reference" href="#%3E%3E%2CParser%5BT%5D%2CParser"
    title="`&gt;&gt;`[T](a: Parser[T]; b: Parser): Parser[T]">`&gt;&gt;`[T](a: Parser[T]; b: Parser): Parser[T]</a></li>

  </ul>
  <ul class="simple nested-toc-section">c
      <li><a class="reference" href="#c%2Cchar"
    title="c(expect: char): Parser[char]">c(expect: char): Parser[char]</a></li>
  <li><a class="reference" href="#c%2Cstring"
    title="c(expect: string): Parser[char]">c(expect: string): Parser[char]</a></li>

  </ul>
  <ul class="simple nested-toc-section">many
      <li><a class="reference" href="#many%2CParser%5BT%5D"
    title="many[T](a: Parser[T]): Parser[seq[T]]">many[T](a: Parser[T]): Parser[seq[T]]</a></li>

  </ul>
  <ul class="simple nested-toc-section">map
      <li><a class="reference" href="#map%2CParser%5BT%5D%2Cproc%28T%29"
    title="map[T, U](a: Parser[T]; fn: proc (x: T): U): Parser[U]">map[T, U](a: Parser[T]; fn: proc (x: T): U): Parser[U]</a></li>

  </ul>
  <ul class="simple nested-toc-section">regex
      <li><a class="reference" href="#regex%2Cstring"
    title="regex(expect: string): Parser[string]">regex(expect: string): Parser[string]</a></li>

  </ul>
  <ul class="simple nested-toc-section">s
      <li><a class="reference" href="#s%2Cstring"
    title="s(expect: string): Parser[string]">s(expect: string): Parser[string]</a></li>

  </ul>
  <ul class="simple nested-toc-section">|
      <li><a class="reference" href="#%7C%2CParser%5BT%5D%2CParser%5BT%5D"
    title="`|`[T](a, b: Parser[T]): Parser[T]">`|`[T](a, b: Parser[T]): Parser[T]</a></li>

  </ul>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#16" id="66">Converters</a>
  <ul class="simple simple-toc-section">
      <ul class="simple nested-toc-section">toStringParser
      <li><a class="reference" href="#toStringParser.c%2CParser%5Bchar%5D"
    title="toStringParser(a: Parser[char]): Parser[string]">toStringParser(a: Parser[char]): Parser[string]</a></li>

  </ul>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#17" id="67">Macros</a>
  <ul class="simple simple-toc-section">
      <ul class="simple nested-toc-section">applyParser
      <li><a class="reference" href="#applyParser.m%2Cuntyped%2Cuntyped%2Cuntyped"
    title="applyParser(parser, input, failType: untyped)">applyParser(parser, input, failType: untyped)</a></li>

  </ul>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#18" id="68">Templates</a>
  <ul class="simple simple-toc-section">
      <ul class="simple nested-toc-section">atLeast
      <li><a class="reference" href="#atLeast.t%2CParser%5BT%5D%2Cint"
    title="atLeast[T](a: Parser[T]; n: int): Parser[seq[T]]">atLeast[T](a: Parser[T]; n: int): Parser[seq[T]]</a></li>

  </ul>
  <ul class="simple nested-toc-section">atMost
      <li><a class="reference" href="#atMost.t%2CParser%5BT%5D%2Cint"
    title="atMost[T](a: Parser[T]; n: int): Parser[seq[T]]">atMost[T](a: Parser[T]; n: int): Parser[seq[T]]</a></li>

  </ul>
  <ul class="simple nested-toc-section">chain
      <li><a class="reference" href="#chain.t%2CParser%5BT%5D%2CParser%5BT%5D%2Cvarargs%5BParser%5BT%5D%5D"
    title="chain[T](p1, p2: Parser[T]; ps: varargs[Parser[T]]): Parser[seq[T]]">chain[T](p1, p2: Parser[T]; ps: varargs[Parser[T]]): Parser[seq[T]]</a></li>

  </ul>
  <ul class="simple nested-toc-section">createParser
      <li><a class="reference" href="#createParser.t%2Cuntyped"
    title="createParser(parser_body: untyped): Parser[string]">createParser(parser_body: untyped): Parser[string]</a></li>

  </ul>
  <ul class="simple nested-toc-section">createParserTo
      <li><a class="reference" href="#createParserTo.t%2Ctypedesc%2Cuntyped"
    title="createParserTo(T: typedesc; parser_body: untyped): Parser[T]">createParserTo(T: typedesc; parser_body: untyped): Parser[T]</a></li>

  </ul>
  <ul class="simple nested-toc-section">fail
      <li><a class="reference" href="#fail.t%2Cstring%2Cstring"
    title="fail[T](inputIn, errorIn: string): ParseResult[T]">fail[T](inputIn, errorIn: string): ParseResult[T]</a></li>

  </ul>
  <ul class="simple nested-toc-section">join
      <li><a class="reference" href="#join.t%2CParser%5Bseq%5B%5D%5D"
    title="join(a: Parser[seq[string or char]]): Parser[string]">join(a: Parser[seq[string or char]]): Parser[string]</a></li>
  <li><a class="reference" href="#join.t%2CParser%5Bseq%5B%5D%5D%2C"
    title="join(a: Parser[seq[string or char]]; delim: string or char): Parser[string]">join(a: Parser[seq[string or char]]; delim: string or char): Parser[string]</a></li>

  </ul>
  <ul class="simple nested-toc-section">oneOf
      <li><a class="reference" href="#oneOf.t%2CParser%5BT%5D%2CParser%5BT%5D%2Cvarargs%5BParser%5BT%5D%5D"
    title="oneOf[T](p1, p2: Parser[T]; ps: varargs[Parser[T]]): Parser[T]">oneOf[T](p1, p2: Parser[T]; ps: varargs[Parser[T]]): Parser[T]</a></li>

  </ul>
  <ul class="simple nested-toc-section">result
      <li><a class="reference" href="#result.t%2CParser%2CT"
    title="result[T](a: Parser; r: T): Parser[T]">result[T](a: Parser; r: T): Parser[T]</a></li>

  </ul>
  <ul class="simple nested-toc-section">skip
      <li><a class="reference" href="#skip.t%2CParser%2CParser"
    title="skip(a, b: Parser): auto">skip(a, b: Parser): auto</a></li>

  </ul>
  <ul class="simple nested-toc-section">succeed
      <li><a class="reference" href="#succeed.t%2Cstring%2CT%2Cstring"
    title="succeed[T](inputIn: string; valueIn: T; tailIn: string): ParseResult[T]">succeed[T](inputIn: string; valueIn: T; tailIn: string): ParseResult[T]</a></li>

  </ul>
  <ul class="simple nested-toc-section">then
      <li><a class="reference" href="#then.t%2CParser%2CParser"
    title="then(a, b: Parser): auto">then(a, b: Parser): auto</a></li>

  </ul>
  <ul class="simple nested-toc-section">times
      <li><a class="reference" href="#times.t%2CParser%2Cauto"
    title="times(a: Parser; n: auto): auto">times(a: Parser; n: auto): auto</a></li>

  </ul>

  </ul>
</li>

</ul>

  </div>
  
  <div class="nine columns" id="content">
  <div id="tocRoot"></div>
  
  <p class="module-desc"></p>
  <div class="section" id="7">
<h1><a class="toc-backref" href="#7">Types</a></h1>
<dl class="item">
<div id="Parser">
<dt><pre><a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">input</span><span class="Other">:</span> <span class="Identifier">string</span><span class="Other">)</span><span class="Other">:</span> <a href="honeycomb.html#ParseResult"><span class="Identifier">ParseResult</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span></pre></dt>
<dd>

<p>A simple parser. Returns a <tt class="docutils literal"><span class="pre"><span class="Identifier">ParseResult</span></span></tt> with the appropriate kind, depending on whether it successfully parsed.</p>
<p>See also:</p>
<ul class="simple"><li><a class="reference external" href="#createParserTo.t,typedesc,untyped">createParserTo</a></li>
<li><a class="reference external" href="#createParser.t,untyped">createParser</a></li>
</ul>


</dd>
</div>
<div id="ParseResult">
<dt><pre><a href="honeycomb.html#ParseResult"><span class="Identifier">ParseResult</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span> <span class="Other">=</span> <span class="Keyword">object</span>
  <span class="Keyword">case</span> <span class="Identifier">kind</span><span class="Operator">*</span><span class="Other">:</span> <a href="honeycomb.html#ParseResultKind"><span class="Identifier">ParseResultKind</span></a>
  <span class="Keyword">of</span> <span class="Identifier">success</span><span class="Other">:</span>
    <span class="Identifier">value</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">T</span>                <span class="Comment">## The value of the successful parse.</span>
  <span class="Keyword">of</span> <span class="Identifier">failure</span><span class="Other">:</span>
    <span class="Identifier">error</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">string</span>           <span class="Comment">## The error message of the failed parse.</span>
  <span class="Identifier">tail</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">string</span>              <span class="Comment">## The remaining unparsed input, or all input when failed.</span>
  <span class="Identifier">fromInput</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">string</span>         <span class="Comment">## The input from which this result was generated.</span>
  </pre></dt>
<dd>

The result of a parser run.

</dd>
</div>
<div id="ParseResultKind">
<dt><pre><a href="honeycomb.html#ParseResultKind"><span class="Identifier">ParseResultKind</span></a> <span class="Other">=</span> <span class="Keyword">enum</span>
  <span class="Identifier">success</span><span class="Other">,</span> <span class="Identifier">failure</span></pre></dt>
<dd>



</dd>
</div>

</dl></div>
<div class="section" id="9">
<h1><a class="toc-backref" href="#9">Lets</a></h1>
<dl class="item">
<div id="alphanumeric">
<dt><pre><a href="honeycomb.html#alphanumeric"><span class="Identifier">alphanumeric</span></a> <span class="Other">=</span> <a href="honeycomb.html#letter"><span class="Identifier">letter</span></a> <span class="Operator">|</span> <a href="honeycomb.html#digit"><span class="Identifier">digit</span></a></pre></dt>
<dd>

A parser that expects one ASCII alphanumeric character.

</dd>
</div>
<div id="anyChar">
<dt><pre><a href="honeycomb.html#anyChar"><span class="Identifier">anyChar</span></a> <span class="Other">=</span> <span class="Identifier">anyCharImpl</span></pre></dt>
<dd>

A parser that succeeds for one character of any non-empty input.

</dd>
</div>
<div id="digit">
<dt><pre><a href="honeycomb.html#digit"><span class="Identifier">digit</span></a> <span class="Other">=</span> <span class="Identifier">c</span><span class="Other">(</span><span class="StringLit">&quot;0123456789&quot;</span><span class="Other">)</span></pre></dt>
<dd>

A parser that expects one ASCII digit character.

</dd>
</div>
<div id="eof">
<dt><pre><a href="honeycomb.html#eof"><span class="Identifier">eof</span></a> <span class="Other">=</span> <span class="Identifier">eofImpl</span></pre></dt>
<dd>

A parser that fails if there is any remaining input.

</dd>
</div>
<div id="letter">
<dt><pre><a href="honeycomb.html#letter"><span class="Identifier">letter</span></a> <span class="Other">=</span> <span class="Identifier">c</span><span class="Other">(</span><span class="StringLit">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span><span class="Other">)</span></pre></dt>
<dd>

A parser that expects one ASCII alphabetical character.

</dd>
</div>
<div id="whitespace">
<dt><pre><a href="honeycomb.html#whitespace"><span class="Identifier">whitespace</span></a> <span class="Other">=</span> <span class="Identifier">regex</span><span class="Other">(</span><span class="StringLit">r&quot;\s+&quot;</span><span class="Other">)</span></pre></dt>
<dd>

A parser that expects at least one whitespace character.

</dd>
</div>

</dl></div>
<div class="section" id="12">
<h1><a class="toc-backref" href="#12">Procs</a></h1>
<dl class="item">
<div id="&,Parser[T],Parser[T]">
<dt><pre><span class="Keyword">func</span> <a href="#%26%2CParser%5BT%5D%2CParser%5BT%5D"><span class="Identifier">`&amp;`</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">,</span> <span class="Identifier">b</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">]</span></pre></dt>
<dd>

<p>Expects each parser in sequence from left to right, creating a <tt class="docutils literal"><span class="pre"><span class="Identifier">seq</span></span></tt> of their results.</p>
<p>See also:</p>
<ul class="simple"><li><a class="reference external" href="#chain.t,Parser[T],Parser[T],varargs[Parser[T]]">chain</a></li>
</ul>


</dd>
</div>
<div id="&,Parser[seq[T]],Parser[T]">
<dt><pre><span class="Keyword">func</span> <a href="#%26%2CParser%5Bseq%5BT%5D%5D%2CParser%5BT%5D"><span class="Identifier">`&amp;`</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">]</span></pre></dt>
<dd>

Same as <a class="reference external" href="#&amp;,Parser[T],Parser[T]">&amp;</a>, but merges <tt class="docutils literal"><span class="pre"><span class="Identifier">seq</span></span></tt>s when the left parser is already one.

</dd>
</div>
<div id="&,Parser[T],Parser[seq[T]]">
<dt><pre><span class="Keyword">func</span> <a href="#%26%2CParser%5BT%5D%2CParser%5Bseq%5BT%5D%5D"><span class="Identifier">`&amp;`</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">]</span></pre></dt>
<dd>

Same as <a class="reference external" href="#&amp;,Parser[T],Parser[T]">&amp;</a>, but merges <tt class="docutils literal"><span class="pre"><span class="Identifier">seq</span></span></tt>s when the right parser is already one.

</dd>
</div>
<div id="*,Parser[T],HSlice[int,int]">
<dt><pre><span class="Keyword">func</span> <a href="#%2A%2CParser%5BT%5D%2CHSlice%5Bint%2Cint%5D"><span class="Identifier">`*`</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">n</span><span class="Other">:</span> <span class="Identifier">HSlice</span><span class="Other">[</span><span class="Identifier">int</span><span class="Other">,</span> <span class="Identifier">int</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">]</span></pre></dt>
<dd>

<p>Expects the parser a number of times in the given range, returning a <tt class="docutils literal"><span class="pre"><span class="Identifier">seq</span></span></tt> of the matches.</p>
<p>See also:</p>
<ul class="simple"><li><a class="reference external" href="#times.t,Parser,auto">times</a></li>
<li><a class="reference external" href="#many,Parser[T]">many</a></li>
<li><a class="reference external" href="#atLeast.t,Parser[T],int">atLeast</a></li>
<li><a class="reference external" href="#atMost.t,Parser[T],int">atMost</a></li>
</ul>


</dd>
</div>
<div id="*,Parser[T],int">
<dt><pre><span class="Keyword">func</span> <a href="#%2A%2CParser%5BT%5D%2Cint"><span class="Identifier">`*`</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">n</span><span class="Other">:</span> <span class="Identifier">int</span><span class="Other">)</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">]</span></pre></dt>
<dd>

Expects the parser a given number of times, returning a <tt class="docutils literal"><span class="pre"><span class="Identifier">seq</span></span></tt> of the matches.

</dd>
</div>
<div id="<<,Parser[T],Parser">
<dt><pre><span class="Keyword">func</span> <a href="#%3C%3C%2CParser%5BT%5D%2CParser"><span class="Identifier">`&lt;&lt;`</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Parser</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span></pre></dt>
<dd>

<p>Expects each parser in sequence from left to right, ignoring the result of the right parser if successful.</p>
<p>See also:</p>
<ul class="simple"><li><a class="reference external" href="#&gt;&gt;,Parser[T],Parser">&gt;&gt;</a></li>
<li><a class="reference external" href="#then,Parser,Parser">then</a></li>
</ul>


</dd>
</div>
<div id=">>,Parser[T],Parser">
<dt><pre><span class="Keyword">func</span> <a href="#%3E%3E%2CParser%5BT%5D%2CParser"><span class="Identifier">`&gt;&gt;`</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Parser</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span></pre></dt>
<dd>

<p>Expects each parser in sequence from left to right, ignoring the result of the left parser if successful.</p>
<p>See also:</p>
<ul class="simple"><li><a class="reference external" href="#&lt;&lt;,Parser[T],Parser">&lt;&lt;</a></li>
<li><a class="reference external" href="#skip,Parser,Parser">skip</a></li>
</ul>


</dd>
</div>
<div id="|,Parser[T],Parser[T]">
<dt><pre><span class="Keyword">func</span> <a href="#%7C%2CParser%5BT%5D%2CParser%5BT%5D"><span class="Identifier">`|`</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">,</span> <span class="Identifier">b</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span></pre></dt>
<dd>

<p>Succeeds if either parser succeeds, attempting them from left to right.</p>
<p>See also:</p>
<ul class="simple"><li><a class="reference external" href="#oneOf.t,Parser[T],Parser[T],varargs[Parser[T]]">oneOf</a></li>
</ul>


</dd>
</div>
<div id="c,char">
<dt><pre><span class="Keyword">func</span> <a href="#c%2Cchar"><span class="Identifier">c</span></a><span class="Other">(</span><span class="Identifier">expect</span><span class="Other">:</span> <span class="Identifier">char</span><span class="Other">)</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">char</span><span class="Other">]</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
<dd>

<p>Creates a parser matching exactly the given character.</p>
<p>See also:</p>
<ul class="simple"><li><a class="reference external" href="#s,string">s</a></li>
<li><a class="reference external" href="#regex,string">regex</a></li>
</ul>


</dd>
</div>
<div id="c,string">
<dt><pre><span class="Keyword">func</span> <a href="#c%2Cstring"><span class="Identifier">c</span></a><span class="Other">(</span><span class="Identifier">expect</span><span class="Other">:</span> <span class="Identifier">string</span><span class="Other">)</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">char</span><span class="Other">]</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
<dd>

Creates a parser matching any one character from the given string.

</dd>
</div>
<div id="many,Parser[T]">
<dt><pre><span class="Keyword">func</span> <a href="#many%2CParser%5BT%5D"><span class="Identifier">many</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">]</span></pre></dt>
<dd>

<p>Expects the parser 0 or more times, returning a <tt class="docutils literal"><span class="pre"><span class="Identifier">seq</span></span></tt> of the matches.</p>
<p>See also:</p>
<ul class="simple"><li><a class="reference external" href="#*,Parser[T],HSlice[int,int]">*</a></li>
<li><a class="reference external" href="#times.t,Parser,auto">times</a></li>
<li><a class="reference external" href="#atLeast.t,Parser[T],int">atLeast</a></li>
<li><a class="reference external" href="#atMost.t,Parser[T],int">atMost</a></li>
</ul>


</dd>
</div>
<div id="map,Parser[T],proc(T)">
<dt><pre><span class="Keyword">func</span> <a href="#map%2CParser%5BT%5D%2Cproc%28T%29"><span class="Identifier">map</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">,</span> <span class="Identifier">U</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">fn</span><span class="Other">:</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">x</span><span class="Other">:</span> <span class="Identifier">T</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">U</span><span class="Other">)</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">U</span><span class="Other">]</span></pre></dt>
<dd>

<p>If the parser is successful, calls <tt class="docutils literal"><span class="pre"><span class="Identifier">fn</span></span></tt> on the parsed value and succeeds with its return value.</p>
<p>See also:</p>
<ul class="simple"><li><a class="reference external" href="#result.t,Parser,T">result</a></li>
</ul>


</dd>
</div>
<div id="regex,string">
<dt><pre><span class="Keyword">func</span> <a href="#regex%2Cstring"><span class="Identifier">regex</span></a><span class="Other">(</span><span class="Identifier">expect</span><span class="Other">:</span> <span class="Identifier">string</span><span class="Other">)</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">string</span><span class="Other">]</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">RegexError</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
<dd>

<p>Creates a parser matching the given regex. The regex must match from the start of the input.</p>
<p>See also:</p>
<ul class="simple"><li><a class="reference external" href="#s,string">s</a></li>
<li><a class="reference external" href="#c,char">c</a></li>
</ul>


</dd>
</div>
<div id="s,string">
<dt><pre><span class="Keyword">func</span> <a href="#s%2Cstring"><span class="Identifier">s</span></a><span class="Other">(</span><span class="Identifier">expect</span><span class="Other">:</span> <span class="Identifier">string</span><span class="Other">)</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">string</span><span class="Other">]</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
<dd>

<p>Creates a parser matching exactly the given string.</p>
<p>See also:</p>
<ul class="simple"><li><a class="reference external" href="#c,char">c</a></li>
<li><a class="reference external" href="#regex,string">regex</a></li>
</ul>


</dd>
</div>

</dl></div>
<div class="section" id="16">
<h1><a class="toc-backref" href="#16">Converters</a></h1>
<dl class="item">
<div id="toStringParser.c,Parser[char]">
<dt><pre><span class="Keyword">converter</span> <a href="#toStringParser.c%2CParser%5Bchar%5D"><span class="Identifier">toStringParser</span></a><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">char</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">string</span><span class="Other">]</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
<dd>

Implicitly converts <tt class="docutils literal"><span class="pre"><span class="Identifier">char</span></span></tt> parsers to <tt class="docutils literal"><span class="pre"><span class="Identifier">string</span></span></tt> parsers for ease of use.

</dd>
</div>

</dl></div>
<div class="section" id="17">
<h1><a class="toc-backref" href="#17">Macros</a></h1>
<dl class="item">
<div id="applyParser.m,untyped,untyped,untyped">
<dt><pre><span class="Keyword">macro</span> <a href="#applyParser.m%2Cuntyped%2Cuntyped%2Cuntyped"><span class="Identifier">applyParser</span></a><span class="Other">(</span><span class="Identifier">parser</span><span class="Other">,</span> <span class="Identifier">input</span><span class="Other">,</span> <span class="Identifier">failType</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span></pre></dt>
<dd>

<p>Applies the given parser, evaluating to its result if successful or returning from the containing function if failed.</p>
<p>This is primarily a tool for simplifying the creation of custom combinators, and should only be used if you know what you're doing. It is only designed to function properly in the context of a block passed to <a class="reference external" href="#createParserTo.t,typedesc,untyped">createParserTo</a>, and will raise a compile warning if used outside of this module.</p>


</dd>
</div>

</dl></div>
<div class="section" id="18">
<h1><a class="toc-backref" href="#18">Templates</a></h1>
<dl class="item">
<div id="atLeast.t,Parser[T],int">
<dt><pre><span class="Keyword">template</span> <a href="#atLeast.t%2CParser%5BT%5D%2Cint"><span class="Identifier">atLeast</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">n</span><span class="Other">:</span> <span class="Identifier">int</span><span class="Other">)</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">]</span></pre></dt>
<dd>

<p>Expects the parser <tt class="docutils literal"><span class="pre"><span class="Identifier">n</span></span></tt> or more times, returning a <tt class="docutils literal"><span class="pre"><span class="Identifier">seq</span></span></tt> of the matches.</p>
<p>See also:</p>
<ul class="simple"><li><a class="reference external" href="#*,Parser[T],HSlice[int,int]">*</a></li>
<li><a class="reference external" href="#times.t,Parser,auto">times</a></li>
<li><a class="reference external" href="#many,Parser[T]">many</a></li>
<li><a class="reference external" href="#atMost.t,Parser[T],int">atMost</a></li>
</ul>


</dd>
</div>
<div id="atMost.t,Parser[T],int">
<dt><pre><span class="Keyword">template</span> <a href="#atMost.t%2CParser%5BT%5D%2Cint"><span class="Identifier">atMost</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">n</span><span class="Other">:</span> <span class="Identifier">int</span><span class="Other">)</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">]</span></pre></dt>
<dd>

<p>Expects the parser <tt class="docutils literal"><span class="pre"><span class="Identifier">n</span></span></tt> or fewer times, returning a <tt class="docutils literal"><span class="pre"><span class="Identifier">seq</span></span></tt> of the matches.</p>
<p>See also:</p>
<ul class="simple"><li><a class="reference external" href="#*,Parser[T],HSlice[int,int]">*</a></li>
<li><a class="reference external" href="#times.t,Parser,auto">times</a></li>
<li><a class="reference external" href="#many,Parser[T]">many</a></li>
<li><a class="reference external" href="#atLeast.t,Parser[T],int">atLeast</a></li>
</ul>


</dd>
</div>
<div id="chain.t,Parser[T],Parser[T],varargs[Parser[T]]">
<dt><pre><span class="Keyword">template</span> <a href="#chain.t%2CParser%5BT%5D%2CParser%5BT%5D%2Cvarargs%5BParser%5BT%5D%5D"><span class="Identifier">chain</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">p1</span><span class="Other">,</span> <span class="Identifier">p2</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">ps</span><span class="Other">:</span> <span class="Identifier">varargs</span><span class="Other">[</span><a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">]</span></pre></dt>
<dd>

<p>Expects the passed parsers in sequence from left to right, creating a <tt class="docutils literal"><span class="pre"><span class="Identifier">seq</span></span></tt> of their results.</p>
<p>See also:</p>
<ul class="simple"><li><a class="reference external" href="#&amp;,Parser[T],Parser[T]">&amp;</a></li>
</ul>


</dd>
</div>
<div id="createParser.t,untyped">
<dt><pre><span class="Keyword">template</span> <a href="#createParser.t%2Cuntyped"><span class="Identifier">createParser</span></a><span class="Other">(</span><span class="Identifier">parser_body</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">string</span><span class="Other">]</span></pre></dt>
<dd>

Same as <a class="reference external" href="#createParserTo.t,typedesc,untyped">createParserTo</a>, but always creates a <tt class="docutils literal"><span class="pre"><span class="Identifier">Parser</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span></span></tt>.

</dd>
</div>
<div id="createParserTo.t,typedesc,untyped">
<dt><pre><span class="Keyword">template</span> <a href="#createParserTo.t%2Ctypedesc%2Cuntyped"><span class="Identifier">createParserTo</span></a><span class="Other">(</span><span class="Identifier">T</span><span class="Other">:</span> <span class="Identifier">typedesc</span><span class="Other">;</span> <span class="Identifier">parser_body</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span></pre></dt>
<dd>

<p>Convenience method for creating a custom <tt class="docutils literal"><span class="pre"><span class="Identifier">Parser</span></span></tt>. Expects the parser's wrapped type as a parameter (not a generic!) and a block which will form the body of the parser.</p>
<p>Inside the given block, <tt class="docutils literal"><span class="pre"><span class="Identifier">input</span></span></tt> is the input string to be parsed. The block should evaluate to a <tt class="docutils literal"><span class="pre"><span class="Identifier">ParseResult</span></span></tt> created by either <tt class="docutils literal"><span class="pre"><span class="Identifier">succeed</span></span></tt> or <tt class="docutils literal"><span class="pre"><span class="Identifier">fail</span></span></tt>, with the <tt class="docutils literal"><span class="pre"><span class="Identifier">tail</span></span></tt> consisting of the remaining unparsed input.</p>
<p>See also:</p>
<ul class="simple"><li><a class="reference external" href="#succeed.t,string,T,string">succeed</a></li>
<li><a class="reference external" href="#fail.t,string,string">fail</a></li>
<li><a class="reference external" href="#createParser.t,untyped">createParser</a></li>
</ul>


</dd>
</div>
<div id="fail.t,string,string">
<dt><pre><span class="Keyword">template</span> <a href="#fail.t%2Cstring%2Cstring"><span class="Identifier">fail</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">inputIn</span><span class="Other">,</span> <span class="Identifier">errorIn</span><span class="Other">:</span> <span class="Identifier">string</span><span class="Other">)</span><span class="Other">:</span> <a href="honeycomb.html#ParseResult"><span class="Identifier">ParseResult</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span></pre></dt>
<dd>

<p>Creates a failed <tt class="docutils literal"><span class="pre"><span class="Identifier">ParseResult</span></span></tt>. Requires <tt class="docutils literal"><span class="pre"><span class="Identifier">T</span></span></tt> to be explicitly specified, except inside of <tt class="docutils literal"><span class="pre"><span class="Identifier">createParserTo</span></span></tt> in some cases.</p>
<p>See also:</p>
<ul class="simple"><li><a class="reference external" href="#succeed.t,string,T,string">succeed</a></li>
<li><a class="reference external" href="#createParserTo.t,typedesc,untyped">createParserTo</a></li>
<li><a class="reference external" href="#createParser.t,untyped">createParser</a></li>
</ul>


</dd>
</div>
<div id="join.t,Parser[seq[]]">
<dt><pre><span class="Keyword">template</span> <a href="#join.t%2CParser%5Bseq%5B%5D%5D"><span class="Identifier">join</span></a><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">string</span> <span class="Keyword">or</span> <span class="Identifier">char</span><span class="Other">]</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">string</span><span class="Other">]</span></pre></dt>
<dd>

Joins a <tt class="docutils literal"><span class="pre"><span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span></span></tt> parser into a single string.

</dd>
</div>
<div id="join.t,Parser[seq[]],">
<dt><pre><span class="Keyword">template</span> <a href="#join.t%2CParser%5Bseq%5B%5D%5D%2C"><span class="Identifier">join</span></a><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">string</span> <span class="Keyword">or</span> <span class="Identifier">char</span><span class="Other">]</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">delim</span><span class="Other">:</span> <span class="Identifier">string</span> <span class="Keyword">or</span> <span class="Identifier">char</span><span class="Other">)</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span>
    <span class="Identifier">string</span><span class="Other">]</span></pre></dt>
<dd>

Joins a <tt class="docutils literal"><span class="pre"><span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span></span></tt> parser into a single string, using the given delimiter.

</dd>
</div>
<div id="oneOf.t,Parser[T],Parser[T],varargs[Parser[T]]">
<dt><pre><span class="Keyword">template</span> <a href="#oneOf.t%2CParser%5BT%5D%2CParser%5BT%5D%2Cvarargs%5BParser%5BT%5D%5D"><span class="Identifier">oneOf</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">p1</span><span class="Other">,</span> <span class="Identifier">p2</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">ps</span><span class="Other">:</span> <span class="Identifier">varargs</span><span class="Other">[</span><a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span></pre></dt>
<dd>

<p>Succeeds if any of the passed parsers succeed, attempting them from left to right.</p>
<p>See also:</p>
<ul class="simple"><li><a class="reference external" href="#|,Parser[T],Parser[T]">|</a></li>
</ul>


</dd>
</div>
<div id="result.t,Parser,T">
<dt><pre><span class="Keyword">template</span> <a href="#result.t%2CParser%2CT"><span class="Identifier">result</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">;</span> <span class="Identifier">r</span><span class="Other">:</span> <span class="Identifier">T</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Parser</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span></pre></dt>
<dd>

<p>If the parser is successful, succeeds with the given <tt class="docutils literal"><span class="pre"><span class="Identifier">r</span></span></tt> as value.</p>
<p>See also:</p>
<ul class="simple"><li><a class="reference external" href="#map,Parser[T],proc(T)">map</a></li>
</ul>


</dd>
</div>
<div id="skip.t,Parser,Parser">
<dt><pre><span class="Keyword">template</span> <a href="#skip.t%2CParser%2CParser"><span class="Identifier">skip</span></a><span class="Other">(</span><span class="Identifier">a</span><span class="Other">,</span> <span class="Identifier">b</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">auto</span></pre></dt>
<dd>

Textual alternative to <a class="reference external" href="#&lt;&lt;,Parser[T],Parser">&lt;&lt;</a>.

</dd>
</div>
<div id="succeed.t,string,T,string">
<dt><pre><span class="Keyword">template</span> <a href="#succeed.t%2Cstring%2CT%2Cstring"><span class="Identifier">succeed</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">inputIn</span><span class="Other">:</span> <span class="Identifier">string</span><span class="Other">;</span> <span class="Identifier">valueIn</span><span class="Other">:</span> <span class="Identifier">T</span><span class="Other">;</span> <span class="Identifier">tailIn</span><span class="Other">:</span> <span class="Identifier">string</span><span class="Other">)</span><span class="Other">:</span> <a href="honeycomb.html#ParseResult"><span class="Identifier">ParseResult</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span></pre></dt>
<dd>

<p>Creates a successful <tt class="docutils literal"><span class="pre"><span class="Identifier">ParseResult</span></span></tt>.</p>
<p>See also:</p>
<ul class="simple"><li><a class="reference external" href="#fail.t,string,string">fail</a></li>
<li><a class="reference external" href="#createParserTo.t,typedesc,untyped">createParserTo</a></li>
<li><a class="reference external" href="#createParser.t,untyped">createParser</a></li>
</ul>


</dd>
</div>
<div id="then.t,Parser,Parser">
<dt><pre><span class="Keyword">template</span> <a href="#then.t%2CParser%2CParser"><span class="Identifier">then</span></a><span class="Other">(</span><span class="Identifier">a</span><span class="Other">,</span> <span class="Identifier">b</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">auto</span></pre></dt>
<dd>

Textual alternative to <a class="reference external" href="#&gt;&gt;,Parser[T],Parser">&gt;&gt;</a>.

</dd>
</div>
<div id="times.t,Parser,auto">
<dt><pre><span class="Keyword">template</span> <a href="#times.t%2CParser%2Cauto"><span class="Identifier">times</span></a><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <a href="honeycomb.html#Parser"><span class="Identifier">Parser</span></a><span class="Other">;</span> <span class="Identifier">n</span><span class="Other">:</span> <span class="Identifier">auto</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">auto</span></pre></dt>
<dd>

Textual alternative to <a class="reference external" href="#*,Parser[T],HSlice[int,int]">*</a>.

</dd>
</div>

</dl></div>

  </div>
</div>

    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br/>
        <small style="color: var(--hint);">Made with Nim. Generated: 2021-12-21 00:45:42 UTC</small>
      </div>
    </div>
  </div>
</div>

</body>
</html>
